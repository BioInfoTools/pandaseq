/**
 * PANDAseq @VERSION@ Illumina assembler
 *
 * Assemble paired FASTQ Illumina reads and strip the region between amplification primers.
 */
[CCode(cheader_filename = "pandaseq.h")]
namespace Panda {
	/**
	 * Codes used for logging conditions during the assembly
	 *
	 * Some of these are errors and some are informational.
	 */
	[CCode(cname = "PandaCode", has_type_id = false, cprefix = "PANDA_CODE_")]
	public enum Code {
		/**
		 * Invalid character in nucleotide data
		 */
		BAD_NT,
		/**
		 * The best computed overlap
		 */
		BEST_OVERLAP,
		/**
		 * A nucleotide copied during reconstruction of the forward sequence
		 */
		BUILD_FORWARD,
		/**
		 * A nucleotide determined during reconstruction of the overlap region
		 */
		BUILD_OVERLAP,
		/**
		 * A nucleotide copied during reconstruction of the reverse sequence
		 */
		BUILD_REVERSE,
		/**
		 * A //k//-mer found in the forward sequence
		 */
		FORWARD_KMER,
		/**
		 * An incorrect Illumina FASTQ header
		 */
		ID_PARSE_FAILURE,
		/**
		 * The //k//-mer table is too small for the sequence
		 */
		INSUFFICIENT_KMER_TABLE,
		/**
		 * A //k//-mer is thrown away due to a collision
		 */
		LOST_KMER,
		/**
		 * A reconstruction is rejected because the quality score is below threshold
		 */
		LOW_QUALITY_REJECT,
		/**
		 * A pair of bases disagree in the reconstruction
		 */
		MISMATCHED_BASE,
		/**
		 * Display information about a module
		 */
		MOD_INFO,
		/**
		 * The computed sequence length is invalid
		 */
		NEGATIVE_SEQUENCE_LENGTH,
		/**
		 * No sequence data is availble in the file
		 */
		NO_DATA,
		/**
		 * The file could not be opened
		 */
		NO_FILE,
		/**
		 * The forward primer cannot be found in the sequence
		 */
		NO_FORWARD_PRIMER,
		/**
		 * The quality information is missing in the FASTQ file
		 */
		NO_QUALITY_INFO,
		/**
		 * The reverse primer cannot be found in the sequence
		 */
		NO_REVERSE_PRIMER,
		/**
		 * The Illumina headers from the forward and reverse sequences do not match
		 */
		NOT_PAIRED,
		/**
		 * A possible overlap has been determined
		 */
		OVERLAP_POSSIBILITY,
		/**
		 * Error parsing FASTQ data
		 */
		PARSE_FAILURE,
		/**
		 * An input file ended in the middle of a FASTQ file
		 */
		PREMATURE_EOF,
		/**
		 * The input read is longer than {@link MAX_LEN}
		 */
		READ_TOO_LONG,
		/**
		 * Reconstruction will commence with provided parameters
		 */
		RECONSTRUCTION_PARAM,
		/**
		 * The number of sequences rejected by a particular module
		 * @see Assembler.module_stats
		 */
		REJECT_STAT,
		/**
		 * A //k//-mer found in the reverse sequence
		 */
		REVERSE_KMER,
		/**
		 * The reconsructed sequence will exceed the memory buffer
		 */
		SEQUENCE_TOO_LONG,
		/**
		 * The PHRED offset should probably be 64, not 33.
		 */
		PHRED_OFFSET;
		[CCode(cname = "panda_code_str")]
		public unowned string to_string();
	}
	/**
	 * Decide what kinds of messages are passed to the logger.
	 */
	[CCode(cname = "PandaDebug", has_type_id = false, cprefix = "PANDA_DEBUG_")]
	[Flags]
	public enum Debug {
		/**
		 * Usual output about assembly.
		 */
		BUILD,
		/**
		 * Input processing-related errors.
		 */
		FILE,
		/**
		 * Extra statistics.
		 */
		STAT,
		/**
		 * Information about building the //k//-mer table (long and boring).
		 */
		KMER,
		/**
		 * Excruciating detail about the reconstruction.
		 */
		RECON,
		/**
		 * Bucket loads of data about mistatches.
		 */
		MISMATCH,
		DEFAULT;
		[CCode(cname = "panda_debug_flags |= ")]
		public void enable();
		[CCode(cname = "panda_debug_flags &= ~")]
		public void disable();
	}

	/**
	 * A single nucleotide
	 */
	[CCode(cname = "panda_nt", has_type_id = false, cprefix = "PANDA_NT_")]
	[Flags]
	public enum Nt {
		/**
		 * Nothing
		 */
		Z,
		/**
		 * Adenine
		 */
		A,
		/**
		 * Cytosine
		 */
		C,
		/**
		 * Guanine
		 */
		G,
		/**
		 * Thyamine
		 */
		T;
		/**
		 * Is nucleotide degenerate?
		 */
		[CCode(cname = "PANDA_NT_IS_DEGN")]
		public bool is_degenerate();
		/**
		 * Is nucleotide all possible values?
		 */
		[CCode(cname = "PANDA_NT_IS_N")]
		public bool is_n();
		/**
		 * Get the nucleotide code for an ASCII character in IUPAC
		 */
		[CCode(cname = "panda_nt_from_ascii")]
		public static Nt from_ascii(char c);
		/**
		 * Get the complement nucleotide code for an ASCII character in IUPAC
		 */
		[CCode(cname = "panda_nt_from_ascii_complement")]
		public static Nt from_ascii_complement(char c);
		/**
		 * Convert a nucleotide to an IUPAC representation
		 */
		[CCode(cname = "panda_nt_to_ascii")]
		public char to_ascii();
	}
	/**
	 * The policy for Illumina tags/barcodes in sequence names.
	 */
	[CCode(cname = "PandaTagging", has_type_id = false, cprefix = "PANDA_TAG_")]
	public enum Tagging {
		/**
		 * The parsing should return an error if the sequence does not have a tag.
		 */
		PRESENT,
		/**
		 * The parsing should return an error if the sequence has a tag.
		 */
		ABSENT,
		/**
		 * The parsing should not care if the sequence a tag.
		 */
		OPTIONAL,
	}

	/**
	 * The manager for an assembly
	 */
	[CCode(cname = "struct panda_assembler", ref_function = "panda_assembler_ref", unref_function = "panda_assembler_unref")]
	[Compact]
	public class Assembler {
		/**
		 * The number of sequences rejected because the reads are unsatisfactory in some way.
		 */
		public long bad_read_count {
			[CCode(cname = "panda_assembler_get_bad_read_count")]
			get;
		}

		/**
		 * The number of sequences processed so far.
		 */
		public long count {
			[CCode(cname = "panda_assembler_get_count")]
			get;
		}

		/**
		 * The number of sequences rejected because they contain degenerate (N) bases.
		 */
		public long degenerate_count {
			[CCode(cname = "panda_assembler_get_degenerate_count")]
			get;
		}

		/**
		 * Reject sequences with degenerate (N) bases.
		 */
		public bool disallow_degenerates {
			[CCode(cname = "panda_assembler_get_disallow_degenerates")]
			get;
			[CCode(cname = "panda_assembler_set_disallow_degenerates")]
			set;
		}

		/**
		 * The minimum error estimation in the sequence data (epsilon)
		 */
		public double error_estimation {
			[CCode(cname = "panda_assembler_get_error_estimation")]
			get;
			[CCode(cname = "panda_assembler_set_error_estimation")]
			set;
		}

		/**
		 * The number of sequences rejected because the overlap could not be determined.
		 */
		public long failed_alignment_count {
			[CCode(cname = "panda_assembler_get_failed_alignment_count")]
			get;
		}

		/**
		 * The forward primer sequence to be stripped
		 *
		 * This is mutually exclusive with {@link forward_trim}
		 */
		public Nt[]? forward_primer {
			[CCode(cname = "panda_assembler_get_forward_primer")]
			get;
			[CCode(cname = "panda_assembler_set_forward_primer")]
			set;
		}

		/**
		 * The amount of forward sequence to strip
		 *
		 * This is mutually exclusive with {@link forward_primer}
		 */
		public size_t forward_trim {
			[CCode(cname = "panda_assembler_get_forward_trim")]
			get;
			[CCode(cname = "panda_assembler_set_forward_trim")]
			set;
		}

		/**
		 * The number of sequences rejected because the quality score is too low.
		 */
		public long low_quality_count {
			[CCode(cname = "panda_assembler_get_low_quality_count")]
			get;
		}

		/**
		 * The minimum overlap two sequences must have to be accepted. It must be greater than one.
		 */
		public int minimum_overlap {
			[CCode(cname = "panda_assembler_get_minimum_overlap")]
			get;
			[CCode(cname = "panda_assembler_set_minimum_overlap")]
			set;
		}

		/**
		 * The number of sequences rejected because the forward primer could not be aligned.
		 */
		public long no_forward_primer_count {
			[CCode(cname = "panda_assembler_get_no_forward_primer_count")]
			get;
		}

		/**
		 * The number of sequences rejected because the reverse primer could not be aligned.
		 */
		public long no_reverse_primer_count {
			[CCode(cname = "panda_assembler_get_no_reverse_primer_count")]
			get;
		}

		/**
		 * The number of sequences accepted.
		 */
		public long ok_count {
			[CCode(cname = "panda_assembler_get_ok_count")]
			get;
		}

		/**
		 * The distribution of overlaps produced so far.
		 */
		public Overlaps overlaps {
			[CCode(cname = "")]
			get;
		}

		/**
		 * Whether to strip the primers before or after assembly.
		 *
		 * Stripping before is faster, but means that there can be no primer sequence in the opposite read.
		 */
		public bool primers_after {
			[CCode(cname = "panda_assembler_get_primers_after")]
			get;
			[CCode(cname = "panda_assembler_set_primers_after")]
			set;
		}

		/**
		 * The reverse primer sequence to be stripped
		 *
		 * This is mutually exclusive with {@link reverse_trim}
		 */
		public Nt[]? reverse_primer {
			[CCode(cname = "panda_assembler_get_reverse_primer")]
			get;
			[CCode(cname = "panda_assembler_set_reverse_primer")]
			set;
		}

		/**
		 * The amount of reverse sequence to strip
		 *
		 * This is mutually exclusive with {@link reverse_primer}
		 */
		public size_t reverse_trim {
			[CCode(cname = "panda_assembler_get_reverse_trim")]
			get;
			[CCode(cname = "panda_assembler_set_reverse_trim")]
			set;
		}

		/**
		 * The numer of sequences where all possible overlaps had to be examined, instead of a quick hashing.
		 */
		public long slow_count {
			[CCode(cname = "panda_assembler_get_slow_count")]
			get;
		}
		/**
		* The minimum quality threshold to have an assembly accepted. Must be between 0 and 1, exclusive.
		*/
		public double threshold {
			[CCode(cname = "panda_assembler_get_threshold")]
			get;
			[CCode(cname = "panda_assembler_set_threshold")]
			set;
		}

		/**
		 * Open a pair of bzipped for assembly.
		 *
		 * @see create_fastq_reader
		 */
		[CCode(cname = "panda_assembler_open_bz2")]
		public static Assembler? open_bz2(string forward, string reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);

		/**
		 * Open a pair of gzipped (or uncompressed files) for assembly.
		 *
		 * @see create_fastq_reader
		 */
		[CCode(cname = "panda_assembler_open_gz")]
		public static Assembler? open_gz(string forward, string reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);

		/**
		 * Create a new assembler from a sequence source.
		 *
		 * @param next the function to call to get the next sequence. The assembler does not manage the memory of the returned arrays, but assume it may use them until the next call or destruction. If not provided, you may use {@link assemble} but not {@link next}
		 * @param logger the function to call to report information to the user.
		 */
		[CCode(cname = "panda_assembler_new")]
		public Assembler(owned NextSeq? next, LogProxy logger);

		/**
		 * Create a new assembler from a sequence source with a custom //k//-mer table size.
		 *
		 * @param num_kmers the number of sequence locations for a particular //k//-mer. This should be small (no more than 10), or the //k//-mer table will be extremely large.
		 * @see Assembler
		 */
		[CCode(cname = "panda_assembler_new_kmer")]
		public Assembler.kmer(owned NextSeq? next, LogProxy logger, size_t num_kmers = 2);

		/**
		 * Create a new assembler for given to FASTQ streams.
		 * @see create_fastq_reader
		 */
		[CCode(cname = "panda_assembler_new_fastq_reader")]
		public Assembler.fastq (owned NextChar forward, owned NextChar reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);

		/**
		 * Assemble a single sequence pair not drawn from the sequence stream.
		 *
		 * This works exactly like {@link next}, but instead of asking the {@link NextSeq} for the data, it expects this information to be provided.
		 */
		[CCode(cname = "panda_assembler_assemble")]
		public unowned result_seq? assemble(identifier id, qual[] forward, qual[] reverse);

		/**
		 * Add a module to this assembly process.
		 *
		 * Sequences will be checked using this module.
		 * @return true if the module was successfully initialised and added
		 */
		[CCode(cname = "panda_assembler_add_module")]
		public bool add_module(Module module);

		/**
		 * Add a collection of modules to this assembly process.
		 * @return the index of the last successfully added module
		 */
		[CCode(cname = "panda_assembler_add_modules")]
		public size_t add_modules([CCode(array_length_type = "size_t")] Module[] modules);

		/**
		 * Clone the configuration of one assembler to another.
		 *
		 * This does not affect the sequence source or logging. Only the primers, trimming, and modules. The recorded statistics are separate.
		 */
		[CCode(cname = "panda_assembler_copy_configuration")]
		public void copy_configuration(Assembler src);

		/**
		 * Review all the modules associated with an assembler.
		 * @return true if callback has seen each module
		 */
		[CCode(cname = "panda_assembler_foreach_module")]
		public bool for_each_module(ModuleCallback callback);

		/**
		 * Log the number of sequences rejected by each module.
		 */
		[CCode(cname = "panda_assembler_module_stats")]
		public void module_stats();

		/**
		 * Assemble the next sequence from the input
		 *
		 * This function will process sequences until one is assembled successfully or no more sequences are available from the input stream, after which it will return null.
		 * The returned sequence becomes invalid after the next call.
		 */
		[CCode(cname = "panda_assembler_next")]
		public unowned result_seq? next();

		/**
		 * Increment reference count.
		 */
		[CCode(cname = "panda_assembler_ref")]
		public unowned Assembler @ref();
		/**
		 * Attached a callback for every sequence that fails to have an overlap.
		 *
		 * This will be called when a sequence fails to have an overlap computed. This does not include sequences that are missing primers or sequences that are assembled and discarded by modules.
		 */
		[CCode(cname = "panda_assembler_set_fail_alignment")]
		public void set_fail_alignment(owned FailAlign? handler);
		/**
		 * Decrement reference count.
		 */
		[CCode(cname = "panda_assembler_unref")]
		public void unref();
	}

	/**
	 * Iterate over a sequence presenting all //k//-mers without ''N''s or other denegerate bases.
	 */
	[CCode(cname = "struct panda_iter", free_function = "panda_iter_free")]
	[Compact]
	public class Iterator {
		/**
		 * The number of useful bits in the output.
		 */
		public size_t bits {
			[CCode(cname = "panda_iter_bits")]
			get;
		}
		/**
		 * The //k//-mer length.
		 */
		public int k {
			[CCode(cname = "panda_iter_k")]
			get;
		}

		/**
		 * Create an iterator over a sequence of nucleotides.
		 * @param seq the sequence to iterate over. This sequence must not be freed during the life of the iterator.
		 * @param reverse true to iterate from the end of the sequence rather than the beginning
		 * @param k the length of the output words. This must range between 1 and 4 * sizeof(size_t). Any other values will be converted to the standard //k//-mer length of 8.
		 */
		[CCode(cname = "panda_iterate_nt")]
		public Iterator.nt([CCode(array_length_type = "size_t")] Nt[] seq, bool reverse = false, int k = 0);
		/**
		 * Iterate over probability-annotated sequence.
		 * @see Iterator.Iterator.nt
		 */
		[CCode(cname = "panda_iterate_qual")]
		public Iterator.qual([CCode(array_length_type = "size_t")] qual[] seq, bool reverse = false, int k = 0);
		/**
		 * Iterate over probability-annotated sequence.
		 * @see Iterator.Iterator.nt
		 */
		[CCode(cname = "panda_iterate_result")]
		public Iterator.result([CCode(array_length_type = "size_t")] result[] seq, bool reverse = false, int k = 0);

		/**
		 * Copy an iterator to a new one, preserving its current state.
		 */
		[CCode(cname = "panda_iter_dup")]
		public Iterator iterator();
		/**
		 * Advance to the next position in the sequence.
		 * @return if null, there are no more //k//-mers in the sequence
		 */
		[CCode(cname = "panda_iter_next")]
		public unowned kmer? next();
		/**
		 * Set an iterator back to the beginning of the sequence.
		 */
		[CCode(cname = "panda_iter_reset")]
		public void reset();
	}

	/**
	 * Logging proxy
	 */
	[CCode(cname = "struct panda_log_proxy", ref_function = "panda_log_proxy_ref", unref_function = "panda_log_proxy_unref")]
	[Compact]
	public class LogProxy {
		/**
		 * Create a new proxy with a callback.
		 */
		[CCode(cname = "panda_log_proxy_new")]
		public LogProxy(owned Logger log);
		/**
		 * Create a new proxy to standard error.
		 */
		[CCode(cname = "panda_log_proxy_new_stderr")]
		public LogProxy.stderr();

		/**
		 * Increase the reference count on a proxy.
		 */
		[CCode(cname = "panda_log_proxy_ref")]
		public void @ref();
		/**
		 * Decrease the reference count on a proxy.
		 */
		[CCode(cname = "panda_log_proxy_unref")]
		public void unref();

		[CCode(cname = "panda_log_proxy_write")]
		public bool write(Code code, identifier id, string message);
	}

	/**
	 * Sequence validity checker
	 */
	[CCode(cname = "struct panda_module", ref_function = "panda_module_ref", unref_function = "panda_module_unref")]
	public class Module {
		/**
		 * The current module API version
		 */
		[CCode(cname = "PANDA_API")]
		public const int API;

		/**
		 * The API version of a module.
		 *
		 * This is only appropriate for loaded modules. Modules constructed by {@link create} will always return {@link API}.
		 */
		public int api {
			[CCode(cname = "panda_module_get_api")]
			get;
		}

		/**
		 * The arguments passed on loading of a module of a module.
		 *
		 * This is only appropriate for loaded modules.
		 */
		public string? args {
			[CCode(cname = "panda_module_get_args")]
			get;
		}

		/**
		 * The description of a module.
		 *
		 * This is only appropriate for loaded modules.
		 */
		public string? description {
			[CCode(cname = "panda_module_get_description")]
			get;
		}

		/**
		 * The name of a module.
		 */
		public string name {
			[CCode(cname = "panda_module_get_name")]
			get;
		}

		/**
		 * The usage information (i.e., help text) of a module.
		 *
		 * This is only appropriate for loaded modules.
		 */
		public string? usage {
			[CCode(cname = "panda_module_get_usage")]
			get;
		}

		/**
		 * The version of a module.
		 *
		 * This is only appropriate for loaded modules.
		 */
		public string? version {
			[CCode(cname = "panda_module_get_version")]
			get;
		}

		/**
		 * Check a sequence after reconstruction for validity.
		 */
		[CCode(cname = "PandaCheck", has_target = false, simple_generics = true)]
		public delegate bool Check<T>(result_seq sequence, T data);
		/**
		 * Check a sequence before reconstruction for validity.
		 */
		[CCode(cname = "PandaPreCheck", has_target = false, simple_generics = true)]
		public delegate bool PreCheck<T>(identifier id, qual[] forward, qual[] reverse, T data);

		/**
		 * Create a module given sequence checking parameters.
		 *
		 * @param name the name of the module, for user interaction
		 * @param check the check function, which must not be null
		 * @param precheck an optional check to be done before the module
		 */
		[CCode(cname = "panda_module_new", simple_generics = true)]
		public static Module create<T>(string name, Check<T>? check, PreCheck<T>? precheck, owned T user);

		/**
		 * Load a module from a string containg the module name and arguments.
		 *
		 * @param path the name or path to a module separated by LT_PATHSEP_CHAR and any arguments to the initialisation function of that module
		 */
		[CCode(cname = "panda_module_load")]
		public static Module load(string path);

		/**
		 * Increment reference count.
		 */
		[CCode(cname = "panda_module_ref")]
		public unowned Module @ref();
		/**
		 * Decrement reference count.
		 */
		[CCode(cname = "panda_module_unref")]
		public void unref();
	}

	/**
	 * A threading-safe wrapper to allow multiple assemblers to share a single data source.
	 */
	[CCode(cname = "struct panda_mux", ref_function = "panda_mux_ref", unref_function = "panda_module_unref")]
	[Compact]
	public class Mux {
		/**
		 * Open a pair of gzipped files for multi-threaded assembled.
		 * @see Assembler.open_gz
		 */
		[CCode(cname = "panda_mux_open_gz")]
		public static Mux? open_gz(string forward, string reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);
		/**
		 * Open a pair of zipped for multi-threaded assembly.
		 *
		 * @see Assembler.open_bz2
		 */
		[CCode(cname = "panda_mux_open_bz2")]
		public static Mux? open_bz2(string forward, string reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);
		/**
		 * Create a new multiplexed data source from a sequence callback.
		 *
		 * The interface will guarantee that only one call will be made at a time to the data source or the logger. However, the interface makes no guarantees in which thread the call will be made. Furthermore, the logger may be call multiple times by different assembly processes (i.e., the logging messages from different sequences may be interleaved).
		 */
		[CCode(cname = "PandaMux")]
		public Mux(owned NextSeq next, LogProxy logger);
		/**
		 * Create a new multiplexed reader for given to FASTQ streams.
		 * @see create_fastq_reader
		 */
		public Mux.fastq(owned NextChar forward, owned NextChar reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);
		/**
		 * Create a new assembler using the multiplexer as it sequence source.
		 *
		 * The new assembler will draw sequences from the original source in a thread-safe way. Each assembler is not thread-safe. This means that, to use the interface correctly, one creates a sequence source, wraps it in a multiplexer, then creates an assembler for every thread. Each assembler should be accessed in only one thread. It may be advisable to create a single assembler and set its configuration, then copy the settings to subsequently created assemblers.
		 * @see Assembler.copy_configuration
		 */
		[CCode(cname = "panda_mux_create_assembler")]
		public Assembler create_assembler();
		/**
		 * Create a new assembler using the multiplexer as it sequence source with a custom //k//-mer table size.
		 * @see Assembler.Assembler.kmer
		 */
		[CCode(cname = "panda_mux_create_assembler_kmer")]
		public Assembler create_assembler_kmer(size_t num_kmers);
		/**
		 * Increase the reference count on a multiplexer.
		 */
		[CCode(cname = "panda_mux_ref")]
		public unowned Mux @ref();
		/**
		 * Attached a callback for every sequence that fails to have an overlap.
		 *
		 * This will be called when a sequence fails to have an overlap computed. This does not include sequences that are missing primers or sequences that are assembled and discarded by modules.
		 *
		 * Concurrency will be handled by the mulitplexer; all calls to this function will be serialised.
		 */
		[CCode(cname = "panda_mux_set_fail_alignment")]
		public void set_fail_alignment(owned FailAlign? handler);
		/**
		 * Decrease the reference count on a multiplexer.
		 */
		[CCode(cname = "panda_mux_unref")]
		public void unref();
	}

	[CCode(cname = "struct panda_assembler", ref_function = "panda_assembler_ref", unref_function = "panda_assembler_unref")]
	[Compact]
	public class Overlaps {
		/**
		 * The longest overlap assembled so far.
		 */
		public size_t size {
			[CCode(cname = "panda_assembler_get_longest_overlap")]
			get;
		}

		/**
		 * Report the number of sequences that have been assembled with the overlap specified.
		 */
		[CCode(cname = "panda_assembler_get_overlap_count")]
		public long get(size_t overlap);
	}

	/**
	 * A set of sequence identifiers against which to match.
	 */
	[CCode(cname = "struct panda_idset", ref_function = "panda_idset_ref", unref_function = "panda_idset_unref")]
	[Compact]
	public class Set {

		/**
		 * Create a new, empty set.
		 */
		[CCode(cname = "panda_idset_new")]
		public Set();

		/**
		 * Add a sequence identifier to a set.
		 */
		[CCode(cname = "panda_idset_add")]
		public void add(identifier id);
		/**
		 * Parse a sequence identifier and add it to the set.
		 * @return true on success
		 * @see identifier.parse_fail
		 */
		[CCode(cname = "panda_idset_add_str")]
		public bool add_str(string id, Tagging policy = Tagging.OPTIONAL, out bool old = null, out unowned string end = null);

		/**
		 * Check if a sequence identifier has been added to the set.
		 */
		[CCode(cname = "panda_idset_contains")]
		public bool contains(identifier id);

		/**
		 * Increase the reference count on a set.
		 *
		 * This is thread-safe.
		 */
		[CCode(cname = "panda_idset_ref")]
		public unowned Set @ref();

		/**
		 * Decrease the reference count on a set.
		 *
		 * This is thread-safe.
		 */
		[CCode(cname = "panda_idset_unref")]
		public void unref();
	}

	/**
	 * Illumina sequence information from the FASTQ header
	 */
	[CCode(cname = "panda_seq_identifier", has_type_id = false, destroy_function = "")]
	public struct identifier {
		string flowcell;
		string instrument;
		int lane;
		int run;
		string tag;
		int tile;
		int x;
		int y;
		[CCode(cname = "panda_seqid_clear")]
		public identifier();
		/**
		 * Parse an Illumina header
		 *
		 * Fills `id` with the parse result. The function returns the direction of the sequence (1 for forward, 2 for reverse) or 0 if an error occurs.
		 */
		[CCode(cname = "panda_seqid_parse")]
		public static int parse(out identifier id, string input, Tagging policy);
		/**
		 * Parse an Illumina header with failure information
		 *
		 * @param old whether the sequence is the old CASAVA 1.4-1.6 format
		 * @param end the remainder of the string if parsing failed.
		 * @see parse
		 */
		[CCode(cname = "panda_seqid_parse_fail")]
		public static int parse_fail(out identifier id, string input, Tagging policy, out bool old, out unowned string end);
		/**
		 * Compare two Illumina headers
		 */
		[CCode(cname = "panda_seqid_equal")]
		public bool equal(identifier other);
		/**
		 * Write the Illumina header to a printf-like function
		 */
		[CCode(cname = "panda_seqid_xprint")]
		public void print(PrintfFunc func);
		/**
		 * Write an Illumina header for a sequence identifier to a file
		 */
		[CCode(cname = "panda_seqid_print")]
		public void to_file(
#if POSIX
Posix.FILE
#else
GLib.FileStream
#endif
file);
		/**
		 * Create an Illumina header for a sequence identifier
		 *
		 * The return string must not be freed and subsequent calls will obliterate the previously returned string.
		 */
		[CCode(cname = "panda_seqid_str")]
		 public unowned string to_string();
	}

	/**
	 * A //k//-mer and its position in the original sequence.
	 */ 
	[CCode(cname = "panda_kmer", has_type_id = false)]
	[SimpleType]
	public struct kmer {
		public size_t kmer;
		public ssize_t posn;
	}

	/**
	 * A single nucleotide with quality information
	 */
	[CCode(cname = "panda_qual", has_type_id = false)]
	public struct qual {
		/**
		 * The nucleotide
		 */
		Nt nt;
		/**
		 * The quality score as a PHRED score
		 */
		char qual;
		/**
		 * Find the best offset of a small sequence in a large sequence.
		 * @param threshold the minimum log probability to match
		 * @param reverse if false, scan the sequence from start to finish, else, scan in the opposite direction
		 * @return 0 if the sequence is not found, or one more than the offset.
		 */
		[CCode(cname = "panda_compute_offset_qual")]
		public static size_t compute_offset(double threshold, bool reverse, [CCode(array_length_type = "size_t")] qual[] haystack, [CCode(array_length_type = "size_t")] Nt[] needle);
		/**
		 * Convert the PHRED quality score to a log probability.
		 */
		public double log_probability {
			[CCode(cname = "panda_quality_log_probability")]
			get;
		}
		/**
		 * Convert the PHRED quality score to a probability.
		 */
		public double probability {
			[CCode(cname = "panda_quality_probability")]
			get;
		}
	}

	/**
	 * A reconstructed nucleotide
	 */
	[CCode(cname = "panda_result", has_type_id = false)]
	public struct result {
		/**
		 * The nucleotide
		 */
		public Nt nt;
		/**
		 * The quality score as a log probability
		 */
		public double p;
		/**
		 * Find the best offset of a small sequence in a large sequence.
		 * @param threshold the minimum log probability to match
		 * @param reverse if false, scan the sequence from start to finish, else, scan in the opposite direction
		 * @return 0 if the sequence is not found, or one more than the offset.
		 */
		[CCode(cname = "panda_compute_offset_result")]
		public static size_t compute_offset(double threshold, bool reverse, [CCode(array_length_type = "size_t")] result[] haystack, [CCode(array_length_type = "size_t")] Nt[] needle);
	}

	/**
	 * A reconstructed sequence with meta information
	 */
	[CCode(cname = "panda_result_seq", has_type_id = false, destroy_function = "")]
	public struct result_seq {
		/**
		 * Number of uncalled bases in the sequence.
		 */
		public size_t degenerates;

		/**
		 * The original forward sequence
		 */
		[CCode(array_length_cname = "forward_length")]
		public qual[] forward;

		/**
		 * The number of nucleotides clipped from the forward sequence
		 */
		public size_t forward_offset;

		/**
		 * The sequence identification information
		 */
		public identifier name;

		/**
		 * Calculated quality score as the geometric mean of the product of the Illumina quality scores of the included bases.
		 *
		 * It will always be between 0 and 1.
		 */
		public double quality;

		/**
		 * The reconstructed sequence with quality information
		 */
		[CCode(array_length_cname = "sequence_length")]
		public result[] sequence;

		/**
		 * The original reverse sequence
		 */
		[CCode(array_length_cname = "reverse_length")]
		public qual[] reverse;

		/**
		 * The number of nucleotides clipped from the reverse sequence
		 */
		public size_t reverse_offset;

		/**
		 * The overlap chosen.
		 */
		public size_t overlap;

		/**
		 * The number of mismatches in the overlap region.
		 */
		public size_t overlap_mismatches;

		/**
		 * The number of overlaps that were examined to determine the one finally used.
		 */
		public size_t overlaps_examined;

		/**
		 * Write an assembly to a FASTA file.
		 */
		[CCode(cname = "panda_output_fasta")]
		public bool write_fasta(
#if POSIX
Posix.FILE
#else
GLib.FileStream
#endif
file);
		/**
		 * Write an assembly to a FASTQ file.
		 */
		[CCode(cname = "panda_output_fastq")]
		public bool write_fastq(
#if POSIX
Posix.FILE
#else
GLib.FileStream
#endif
file);
	}

	/**
	 * The default number of locations in the //k//-mer look up table.
	 *
	 * When attempting to align the sequences, the {@link Assembler} will store the location of every //k//-mer in a table. If the same //k//-mer is present multiple times, only the first ones will be store until the table is full. If the sequences are highly repetitive, lost positions can prevent good alignments.
	 */
	[CCode(cname = "PANDA_DEFAULT_NUM_KMERS")]
	public const size_t DEFAULT_NUM_KMERS;

	/**
	 * Maximum length of a sequence
	 */
	[CCode(cname = "PANDA_MAX_LEN")]
	public const int MAX_LEN;

	/**
	 * Handle a failed alignment
	 *
	 * This is called when an assembler fails to align a sequence because it can't compute a reasonable overlap.
	 * @param assembler The assembler that made the attempt
	 * @param id the sequence id of the failed pair
	 * @param forward the forward read
	 * @param reverse the reverse read
	 */
	[CCode(cname = "PandaFailAlign", has_type_id = false)]
	public delegate void FailAlign(Assembler assembler, identifier id, [CCode(array_length_type = "size_t")] qual[] forward, [CCode(array_length_type = "size_t")] qual[] reverse);

	/**
	 * Log an error/event
	 *
	 * If the function returns false, assembly will be halted.
	 * @see Code
	 */
	[CCode(cname = "PandaLogger")]
	public delegate bool Logger(Code code, identifier? id, string? message);
	/**
	 * A callback for iterating over the current modules.
	 * @param assembler the assembler which is being queried
	 * @param module the module selected
	 * @param rejected the number of sequences rejected by this module in the context of the current assembler
	 * @return true to continue iterating, false to stop
	 */
	[CCode(cname = "PandaModuleCallback")]
	public delegate bool ModuleCallback(Assembler assembler, Module module, size_t rejected);

	/**
	 * Get the next character from a FASTQ file or EOF.
	 *
	 * For assembly from an alternate source of data, this function returns the next character in the stream.
	 */
	[CCode(cname = "PandaNextChar")]
	public delegate int NextChar();

	/**
	 * Get the next sequence pair.
	 *
	 * For assembly from a non-FASTQ text source, this function can provide the next sequence. The function must provide the sequences and metadata for assembly by modifing the values of its parameters.
	 * @param id the identifier information for the sequence pair
	 * @param forward the location of the parsed sequence data of the forward read.
	 * @param reverse the location of the parsed sequence data of the reverse read.
	 */
	[CCode(cname = "PandaNextSeq")]
	public delegate bool NextSeq(out identifier id, out unowned qual[] forward, out unowned qual[] reverse);

	/**
	 * Write a finsihed sequence to an appropriate place.
	 * @param sequence the sequence from assembly
	 */
	[CCode(cname = "PandaOutputSeq")]
	public delegate bool OutputSeq(result_seq sequence);

	[CCode(cname = "PandaPrintf", instance_pos = 0)]
	[PrintfFormat]
	public delegate void PrintfFunc(string format, ...);

	/**
	 * Create an object to read sequences from two character streams of FASTQ data
	 *
	 * @param forward the stream of forward characters, called every time a new character is required.
	 * @param reverse the stream of reverse characters, called every time a new character is required.
	 * @param logger the logging proxy to use during assembly.
	 * @param qualmin the quality to subtract from the incoming file (usually 33 or 64, depending on CASAVA version)
	 * @param policy method to handle unbarcoded sequences
	 */
	[CCode(cname = "panda_assembler_create_fastq_reader")]
	public static NextSeq create_fastq_reader(owned NextChar forward, owned NextChar reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);

	/**
	 * The current module API version of the running library
	 */
	[CCode(cname = "panda_api_version")]
	int get_api_version();

	/**
	 * The current version string
	 */
	[CCode(cname = "panda_version")]
	public unowned string get_version();

	/**
	 * Write errors and information to a file.
	 */
	[CCode(cname = "panda_logger_file")]
	public bool file_logger(Code code, identifier? id, string? message,
#if POSIX
Posix.FILE
#else
GLib.FileStream
#endif
file);

	/**
	 * Write an unassembled sequence to a FASTA file as a concatenated pair.
	 */
	[CCode(cname = "PANDA_FAIL")]
	public FailAlign? create_fail_writer(string file, bool append);

	/**
	 * Compute log(1 - exp(p)) efficiently.
	 *
	 * See [[http://cran.r-project.org/web/packages/Rmpfr/vignettes/log1mexp-note.pdf|Mächler, 2012]].
	 */
	[CCode(cname = "panda_log1mexp")]
	public double log1mexp(double p);

	/**
	 * Open a pair of gzipped (or uncompressed files).
	 *
	 * @param qualmin the value to strip from the quality scores. Usually 33 or 64, depending on CASAVA version.
	 */
	[CCode(cname = "panda_open_gz")]
	public NextSeq? open_gz(string forward, string reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);

	/**
	 * Open a pair of bzipped files.
	 *
	 * @param qualmin the value to strip from the quality scores. Usually 33 or 64, depending on CASAVA version.
	 */
	[CCode(cname = "panda_open_bz2")]
	public NextSeq? open_bz2(string forward, string reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);

	/**
	 * Spawn threads and assemble sequences.
	 * @param threads the number of threads to spawn
	 * @param assembler the main assembler to use. If multiple threads are to be used, the configuration of this assembler will be copied to all the slave assemblers.
	 * @param mux the multiplexer to use. If null, no threads will be created. The provided assembler must be a product of this multiplexer.
	 * @param output the delegate that will write assembled sequences to where they belong.
	 */
	[CCode(cname = "panda_run_pool")]
	public bool run_pool(int threads, owned Assembler assembler, owned Mux? mux, owned OutputSeq output);

	/**
	 * The current flags used be the assember to report errors. Some errors are always reported.
	 */
	[CCode(cname = "panda_debug_flags")]
	public Debug debug_flags;

	namespace StdArgs {
		/**
		 * The standard list of assembler-only arguments for PANDAseq binaries.
		 */
		[CCode(cname = "panda_tweak_assembler", array_length_cexpr = "panda_stdargs_length", array_length_type = "size_t")]
		public const Tweak.assembler?[] list;
		/**
		 * The strip primers after switch (-a).
		 */
		[CCode(cname = "panda_stdargs_primers_after")]
		public const Tweak.assembler primers_after;
		/**
		 * The minimum length filter switch (-l).
		 */
		[CCode(cname = "panda_stdargs_min_len")]
		public const Tweak.assembler min_len;
		/**
		 * The maximum length filter switch (-L).
		 */
		[CCode(cname = "panda_stdargs_max_len")]
		public const Tweak.assembler max_len;
		/**
		 * The no N's switch (-N).
		 */
		[CCode(cname = "panda_stdargs_degenerates")]
		public const Tweak.assembler degenerates;
		/**
		 * The forward primer filter switch (-p).
		 */
		[CCode(cname = "panda_stdargs_forward_primer")]
		public const Tweak.assembler forward_primer;
		/**
		 * The reverse primer filter switch (-q).
		 */
		[CCode(cname = "panda_stdargs_reverse_primer")]
		public const Tweak.assembler reverse_primer;
		/**
		 * The threshold filter switch (-t).
		 */
		[CCode(cname = "panda_stdargs_threshold")]
		public const Tweak.assembler threshold;

		/**
		 * The standard argument handler for a pair of FASTQ files from Illumina.
		 */
		[CCode(cname = "struct panda_args_fastq", free_function = "panda_args_fastq_free")]
		[Compact]
		public class FastqArgs {
			/**
			 * Command line arguments for a pair of FASTQ files from Illumina.
			 */
			[CCode(cname = "panda_args_fastq_args", array_length_cexpr = "panda_args_fastq_args_length", array_length_type = "size_t")]
			public const Tweak.general?[] args;

			/**
			 * Create a new argument handler.
			 */
			[CCode(cname = "panda_args_fastq_new")]
			public FastqArgs();

			/**
			 * Process the command line arguments for the FASTQ argument handler.
			 */
			[CCode(cname = "panda_args_fastq_tweak")]
			public bool tweak(char flag, string argument);

			/**
			 * Initialise the sequence stream for the FASTQ argument handler.
			 */
			[CCode(cname = "panda_args_fastq_opener")]
			public NextSeq? opener(LogProxy logger, out FailAlign? fail);

			/**
			 * Do additional assembly setup for the FASTQ argument handler.
			 */
			[CCode(cname = "panda_args_fastq_setup")]
			public bool setup(Assembler assembler);
		}
	}

	namespace Tweak {
		/**
		 * Process a command-line flag specified by the user.
		 * @param assembler the assembler to which to make the adjustments
		 * @param flag the command line flag specified
		 * @param argument the command line argument, or null if not set.
		 * @param is_set whether the command line argument is given in the case of boolean flags.
		 * @return whether the flag was parsed successfully
		 */
		[CCode(cname = "PandaTweakAssembler", has_type_id = false, has_target = false)]
		public delegate bool AssemblerHandler(Assembler assembler, char flag, owned string? argument, bool is_set);

		/**
		 * Process a command-line flag specified by the user.
		 * @param flag the command line flag specified
		 * @param argument the option passed specified with the flag, if requested.
		 * @param user_data the context
		 * Returns: whether the flag was parsed succesfully
		 */
		[CCode(cname = "PandaTweakGeneral", has_type_id = false, has_target = false, simple_generics = true)]
		public delegate bool GeneralHandler<T>(T user_data, char flag, string? argument);

		/**
		 * Create a sequence reader after argument parsing.
		 *
		 * This returns a sequence source and a failure handler so that assembly can proceed.
		 * @param user_data the context
		 * @param logger The logging proxy to use, if needed.
		 * @param fail the handler for any sequences which do not align, if desired.
		 * @param help if true, the help text will be displayed when the function exits.
		 * @return the sequence source, or null to indicate a failure
		 */
		[CCode(cname = "PandaOpener", has_type_id = false, has_target = false, simple_generics = true)]
		public delegate NextSeq Opener<T>(T user_data, LogProxy logger, out FailAlign? fail);

		/**
		 * Perform any modifications to the assembler after creation.
		 */
		[CCode(cname = "PandaSetup", has_type_id = false, has_target = false, simple_generics = true)]
		public delegate bool Setup<T>(T user_data, Assembler assembler);

		/**
		 * Describes a command line option that can be applied to an assembler.
		 */
		[CCode(cname = "panda_tweak_assembler", has_type_id = false)]
		public struct assembler {
			/**
			 * Construct a new list by combining existing lists.
			 * @param array The storage location of the array. If the array is null, it will be allocated. It must be in reallocable memory.
			 * @param additions The array whose items to copy.
			 */
			[CCode(cname = "panda_tweak_assembler_append")]
			public static void append([CCode(array_length_type = "size_t")] ref assembler?[]? array, [CCode(array_length_type = "size_t")] assembler?[] additions);

			/**
			 * Sort a list of arguments into flag order.
			 */
			[CCode(cname = "panda_tweak_assembler_sort")]
			public static void sort([CCode(array_length_type = "size_t")] assembler?[] array);

			/**
			 * The command line option.
			 */
			char flag;
			/**
			 *  The name of the argument as it appears in the help. If null, the argument is assumed to be boolean.
			 */
			string? takes_argument;
			/**
			 * The description of the option.
			 */
			string? help;
			/**
			 * The callback to make the appropriate changes to the assembler.
			 */
			AssemblerHandler setup;
		}

		/**
		 * Describes a command line option.
		 */
		[CCode(cname = "panda_tweak_general", has_type_id = false)]
		public struct general {
			/**
			 * Construct a new list by combining existing lists.
			 * @param array The storage location of the array. If the array is null, it will be allocated. It must be in reallocable memory.
			 * @param additions The array whose items to copy.
			 */
			[CCode(cname = "panda_tweak_general_append")]
			public static void append([CCode(array_length_type = "size_t")] ref general?[]? array, [CCode(array_length_type = "size_t")] general?[] additions);

			/**
			 * Sort a list of arguments into flag order.
			 */
			[CCode(cname = "panda_tweak_general_sort")]
			public static void sort([CCode(array_length_type = "size_t")] general?[] array);

			/**
			 * The command line option.
			 */
			char flag;
			/**
			 * Whether the flag needs to be specified.
			 *
			 * This is used in the help output only.
			 */
			bool optional;
			/**
			 * The name of the argument as it appears in the help. If null, the argument is assumed to be boolean.
			 */
			string? takes_argument;
			/**
			 * The callback to record the appropriate information.
			 */
			string help;
		}

		/**
		 * Parse command line arguments to in order to construct assemblers.
		 *
		 * This is meant to serve as a general framework for parsing command line arguments with maximum code reuse. There are two kinds of arguments: assembler-only and general. Assembler-only arguments need no context (i.e., they on modify the assembler based on their argument). General arguments might do this or they might be involved in selecting the sequence source.
		 *
		 * Lists of command line arguments are passed in and parsed. The opener is then called to open the data source and provide a sequence source. Then, an assembler and multiplexer will be created. All the assembler-only arguments and any additional setup are applied to the assembler. Any needed modules are loaded. Finally, the assembler and multiplexer are output, for use by the thread pool code.
		 * @param args the strings from the command line
		 * @param assembler_args descriptors of all the assembler-only command line arguments
		 * @param general_args descriptors of all the command line arguments userstood by the callbacks
		 * @param tweak a callback for every command line argument matching a general argument
		 * @param opener a callback to open the sequence source
		 * @param assembler_setup a callback to configure the assembler
		 * @param assembler the assembler constructed after argument parsing
		 * @param mux the multiplexer constructed after argument parsing
		 * @param threads the number of threads the user wishes to use
		 * @return whether command line parsing was successful and the output parameters have been populated
		 */
		[CCode(cname = "panda_parse_args", simple_generics = true)]
		public bool parse_args<T>(string[] args, [CCode(array_length_type = "size_t")] Tweak.general?[] general_args, [CCode(array_length_type = "size_t")] Tweak.assembler?[] assembler_args, GeneralHandler<T> tweak, Opener<T> opener, Setup<T> assembler_setup, T user_data, out Assembler? assembler, out Mux? mux, out int threads, out OutputSeq output);
	}
}
